\chapter{Ergebnisse}
\label{ch:ergebnisse}

\section{Analyse des LSS- und LSR-Formates}

% - Keine Dokumentation zum Aufbau des XML vorhanden
% - Lösung: Testdokumente erstellen und von da aus Format herausfinden
% 	- Erst simples Dokument mit Textfragen und zwei Fragegruppen

In der Online-Dokumetation von LimeSurvey gibt es zwar eine Sektion zum Thema Export und Export-Formate, dieses Kapitel war aber bis vor kurzem leer.
Auch jetzt enthält das Kapitel nur eine oberflächliche Beschreibung der Formate, die genaue Struktur wird nicht erklärt.
Da diese allerdings benötigt wird, um eine Konvertierung vornehmen zu können, muss zunächst ermittelt werden, wie die .lss- und .lsr-Dateien genau aufgebaut sind.


Dies wurde bewerkstelligt, indem zunächst ein simples Dokument erstellt wurde, welches eine Fragegruppe und drei Freitextfragen enthält.
Dafür wurde eine Instanz der LimeSurvey Community Edition benötigt, diese aufzusetzen war dank existierenden Docker-Compose-Dateien relativ simpel.
Nachdem die Struktur der Umfrage selbst, sowie der Fragegruppen so ermittelt wurde, wurden komplexere Dateien erstellt.
Diese enthielten zunächst Fragen mit festen Antwortmöglichkeiten, also vor allem Maskenfragen und Multiple Choice Fragen.
Nachdem so auch die Struktur der Antworten deutlich geworden war, wurden zuletzt die Matrixfragen eingebaut und die Struktur der Subfragen ermittelt.
Das Ergebis dieser Analyse wird im Folgenden dargestellt (Es werden nicht alle existierenden Elemente angesprochen, sondern nur die für diese Arbeit relevanten, eine vollständige Auflistung kann im %TODO
gefunden werden):

\subsection{Grundlegende Struktur}

Das Root-Element in LSS ist \el{document}.
Hier sind zuerst grundlegende Informationen wie die Datenbank-Version und den Typ des Dokuments enthalten.
Jedes der größeren Hauptelemente in \el{document} hat die gleiche Struktur.
Es gibt zwei Elemente, \el{fields} und \el{rows}. In \el{rows} gibt es \el{row} Elemente, welche die Informationen selbst in weiteren Elementen enthalten.
In \el{fields} gibt es \el{fieldname} Elemente, wobei es für jedes mögliche Element in \el{rows/row} ein \el{filedname} Element mit dem Namen als Text gibt.

\subsection{Fragegruppen}

Im Element \el{groups} werden Metadaten über Fragegruppen gesammelt, wie zum Beispiel die Gruppen-ID.
Diese sind aber auch in \el{group\_l10ns} enthalten, darüber hinaus sind auch noch weitere Inhalte wie Gruppenname und Sprache in diesem Element.
Daher werden später keine Informationen aus \el{groups} später verwendet.
Ein \el{row} Element steht hier für eine Fragegruppe.

\subsection{Fragen}

Das Element \el{questions} enthält Metadaten über Fragen, wie \el{qid}, \el{gid}, \el{title}, \el{type}.
Ein \el{row} Element steht hier für eine Frage, pro richtiger Frage in der Umfrage gibt es ein Element in \el{questions}.
\el{subquestions} hat Subfragen von Arrays, Matrizen et cetera. Diese sind via \el{parent\_qid} and ein Element aus \el{questions} gekoppelt.
Auch in \el{subquestions} sind nur Metadaten enthalten, jede Subfrage hat, wie die richtigen Fragen auch, eine Fragen-ID.
In \el{question\_l10ns} gibt es nun die tatsächliche Frage in \el{question}, weiterhin gibt es mit \el{help} einen Hilfstext für die Frage, \el{language} gibt die Sprache des Fragetextes an.
Für jedes Element aus \el{question} und \el{subquestion} gibt es hier ein Element pro Sprache.
Referenziert werden diese mit der \el{qid}.

\el{question\_attributes} enthält Informationen über eine Frage wie ein Prä-/Suffix zu der Antwort, RegEx-Validations-Ausdrücke für die Antwort, Timings und Informationen zur Darstellung einer Frage (Textfeldbreite, Default-Antworten).

\subsection{Antwortmöglichkeiten}

Es gibt eine Reihe an Fragen, für die es eine Menge an vordefinierten Antworten gibt.
Diese sind entweder schon durch die Frage festgelegt, wie bei dem Fragetyp \el{5 Punkte Wahl} oder dem Typ \el{Geschlecht}, oder der Umfrage-Ersteller kann sie selber angeben.
Sind die Möglichkeiten schon durch den Typ festgelegt, werden die Antwortmöglichkeiten implizit ermittelt und nie konkret im Dokument niedergeschrieben.
Hat der Umfrage-Ersteller die Möglichkeiten selber festgelegt, werden diese in \el{answers} und \el{answer\_l10ns} gespeichert.
In \el{answers} gibt es dabei wieder Metadaten wie \el{qid}, \el{aid}, und einen \el{code}.
In \el{answer\_l10ns} hingegen gibt es den Antworttext in \el{answer}, eine \el{aid} zur Verknüpfung mit den Metadaten und die Sprache in \el{language}.
Für jedes Element aus \el{answers} gibt es pro Sprache ein Element in \el{answer\_l10ns}.

\subsection{Umfrage-Metadaten}
\label{a:survey_meta}

In \el{surveys} findet man Metadaten über die Umfrage, allerdings sind keine davon für die Konvertierung relevant.
Beispiele wären Daten darüber, ob Willkommenstexte angezeigt werden sollen oder ob IP-Adressen der Teilnehmer gespeichert werden sollen.
\el{surveyls\_languagesettings} enthält relevante Informationen wie die \el{surveyls\_id}, den Titel in \el{surveyls\_title} und eine Beschreibung der Umfrage in \el{surveyls\_description}.
\el{themes} und \el{themes\_inherited} enthalten Informationen über die visuelle Darstellung der Umfrage in LimeSurvey.

\subsection{LSR-Aufbau}

Auch für die Antworten wurde die gleiche Strategie wie für die Umfragestruktur verwendet.
Die Ergebnisse sind wie folgt:

Das Hauptelement ist wieder \el{Document}, zuerst gibt es wieder einige Metadaten wie der Typ des Dokuments, die Datenbank-Version und die Sprache.
Dann gibt es ein \el{responses} Element, welches dieselbe grundlegende Struktur wie die Elemente in der LSS-Datei besitzt.
Für jeden Teilnehmer der Umfrage gibt es ein Element vom Typ \el{row}.
Dies enthält eine ID, das Absendedatum, die Sprache und einen Seed.
Dann kommen die Antworten, wobei es für jede Frage bzw. Subfrage ein Element mit folgendem Namensschema gibt: \el{\_\{Survey-ID\}X\{GID\}X\{QID\}\{SQID\}?\{ext\}?}, wobei \el{ext} folgendes sein kann (\enquote{other}$\vert$\enquote{comment}).
Man kann bereits am Format sehen, dass es auch für die \enquote{other} und Kommentar-Felder hier eine separate Antwort gibt.

\subsection{Erstellung eines XML-Schemas}

Da die Struktur der Umfrage nun bekannt ist, wird ein XML-Schema für das LSS-Format erstellt.
Das sorgt einerseits für eine wesentlich bessere Übersicht über den Aufbau, das kann für zukünftige Arbeit nützlich sein.
Andererseits lässt sich dieses Schema später verwenden, um zu überprüfen, ob es sich bei der Eingabedatei um eine valide LSS-Datei handelt.

\section{Mapping}

Da der Aufbau beider Formate nun bekannt ist, muss überlegt werden, wie man beide LimeSurvey-Formate auf ODM abbilden kann. Im Folgenden werden die verschiedenen Teile von LSS nacheinander abgehandelt und es wird erklärt, wie mit überschüssigen Elementen in ODM ungegangen wird.
Der Text wird dabei das Vorgehen beschreiben, die exakten Elementnamen können in den Grafiken nachgesehen werden.

\subsection{Dummy Elemente in ODM}

% - ODM kann mehr Beziehungen in Studien darstellen
% - Es müssen Dummy-Elemente angelegt werden, weil LimeSurvey diese Elemente nicht hat, sie aber in ODM vorkommen müssen
% - Betroffen: GlobalVariables, StudyEvent

ODM besitzt mehr Möglichkeiten, mögliche Abläufe einer Studie oder Umfrage darzustellen, da es als generisches Format natülich mehr Einsatzzwecke abdecken soll, als das LSS-Format.
Dementsprechend gibt es mehrere Wege, LSS auf ODM abzubilden.
Durch die hier getroffenen Entscheidungen werden die Elemente \el{StudyEvent} und \el{GlobalVariables} überflüssig,	da es sich dabei um für eine Studie relevante Felder handelt, es soll aber nur eine Umfrage innerhalb einer Studie erstellt werden.

Da diese Elemente dennoch zwingend in ODM vorkommen müssen, werden die globalen Variablen leer gelassen und es wird ein \el{StudyEvent} erstellt, welches unabhängig von der Eingabe-Datei immer die gleichen Dummy-Werte hat.
Weiterhin wird die \el{OID} des \el{Study} Elements auch auf einen Dummy-Wert gesetzt, da wir hier ebenfalls kein Äquivalent in LSS haben.
Die \el{OID} der \el{MetaDataVersion} soll die Studien-ID behinhalten, da die Version der Metadaten die gesamte Umfrage enthält, es ergibt also Sinn, hier keinen Dummy-Wert einzusetzen sondern eine Referenz auf die Studie mit einzubringen.

\subsection{Umfrage-Eigenschaften}
\label{m:survey_meta}

Innerhalb unseres Dummy-\el{StudyEvent's} gibt es nun ein Formular, dieses soll die Umfrage repräsentieren.
Das \el{Repeating} Attribut wird auf \enquote{No} gesetzt, da die Umfrage nur einmal pro Teilnehmer ausgefüllt werden soll, füllt jemand sie mehrmals aus, gerade wenn es keine vorher festgelegten Nutzer gibt, gilt das als zwei verschiedene Teilnehmer %TODO: Wenn man eine feste Teilnehmer-Liste hat, kann man dann eine Umfrage mehrmals ausfüllen?
Da das Formular die Umfrage repräsentiert, sollen sie dieselbe ID nutzen, als \el{Name} wird der Titel der Umfrage gesetzt. Die Beschreibung wird ebenfalls in das Formular übernommen.

\subsection{Fragegruppen}
\label{m:qg}
Fragegruppen in LimeSurvey sind fast äquivalent zu \el{ItemGroup's} in ODM.
Entsprechend wird für jede Fragegruppe eine \el{ItemGroupDef} erstellt, die ID wird direkt in ODM übernommen, der Titel wird als Name verwendet.
Der Hilfetext der Frage wird zur Beschreibung in ODM.
Das Attribut \el{Repeating} wird wieder auf \enquote{No} gesetzt. %TODO: Korrekt?
Entsprechende Referenzen auf die Fragegruppen werden zur \el{FormDef} hinzugefügt.

\begin{figure}[h]
	\makebox[\linewidth][c]{%
		\begin{subfigure}[b]{.6\textwidth}
			\centering
			\includegraphics[width=.95\textwidth]{./img/m_survey_props.png}
			\caption{Mapping der Umfrage-Eigenschaften}
		\end{subfigure}%
		\begin{subfigure}[b]{.6\textwidth}
			\includegraphics[width=.95\textwidth]{./img/m_groups.png}
			\caption{Mapping der Fragegruppen}
		\end{subfigure}%
		}
		\caption{Diagramme für Fragegruppen und Umfragen}
\end{figure}

\subsection{Fragen}

% - Aus einer Frage in LS werden pot. mehrere ItemDef's in ODM (fragetypabhängig)
% - Elemente aus \el{Questions} und \el{Subquestions} und \el{Question\_l10ns} werden genutzt

Grob gesprochen wird die Frage aus LimeSurveys \el{question\_l10ns} Element bei ODM in \el{Question/TranslatedText} der Fragendefinition eingetragen, die Sprache aus \el{language} wird im Attribut \el{xml:lang} des \el{TranslatedText} eingetragen.
Wie schon bei den Fragegruppen wird die ID übernommen und der Titel wird zum Namen.
Der Hilfstext der Frage wird zur Beschreibung in ODM.
Die Angabe, ob eine Frage verpflichtend ist, kann ebenfalls übernommen werden, allerdigs wird diese in ODM in der Fragen-Referenz eingetragen, nicht in der Definition.

In ODM gibt es allerdings keine Subfragen, dementsprechend muss eine Frage in LimeSurvey potentiell in mehrere Fragen, eine pro Subfrage, umgewandelt werden, damit diese dann in ODM eingefügt werden können.
Dementsprechend muss jeder Fragetyp aus LimeSurvey einzeln behandelt werden, wobei die Behandlung eines Fragetyps teils in der Behandlung eines anderen Fragetyps enthalten ist.
Auch sind die Behandlungen für mehrere Fragetypen identisch.
Zum Beispiel werden die Fragetexte der Hauptfrage und der Subfrage konkateniert, um so eine neue Frage  zu formulieren.
Für die Festlegung der \el{OID} von Subfragen wird die \el{qid} der Hauptfrage mit dem Titel der Subfrage konkateniert.
Gründe dafür werden in \cref{im:ans} dargelegt.
Im folgenden werden alle Behandlungen erklärt, mit einer Angabe, für welche Fragetypen diese genutzt werden.

\subsubsection{Einfachauswahl}
\label{e:sc}

Hier werden die Fragen 1:1 abgebildet, die Antwortmöglichkeiten werden in einer CodeList gespeichert.
Für den Typ \el{Liste mit Kommentar} wird eine weitere Frage hinzugefügt, deren \el{OID} die \el{qid} der Frage ist, allerdings wird noch \enquote{comment} angehangen.
An den Fragetext wird ebenfalls das gleiche angehangen.
Bei dem Bild der \el{Image-Select-List} besteht das Problem, dass dieses nur mittels Link zum Bild auf dem LimeSurvey-Server eingebettet ist.
Beim Übertragen der Fragen ist somit auch nur dieser Link enthalten.

\subsubsection{Matrix}

Für die Matrizen mit Zahlen- oder Freitextantworten wird eine Frage pro Zelle der Matrix hinzugefügt.
Für alle weiteren Typen dieser Kategorie bis auf die \el{Dual Matrix} wird eine Frage pro Subfrage hinzugefügt, die gleiche Liste an Antwortmöglichkeiten wird für jede Subfrage verwendet.
Die \el{Dual Matrix} wird behandelt, als würde die gleiche Frage zwei Mal mit unterschiedlichen Antwortmöglichkeiten dargestellt.

\subsubsection{Multiple Choice}

Hier wird eine Frage pro Subfrage hinzugefügt, %TODO Kommentare
Das Bild beim Typ \el{Image Select} wird wie schon bei \cref{e:sc} nur auf Umwegen übernommen.

\subsubsection{Textfragen}

Hier wird der Fragetext wie oben erklärt übertragen, als \el{DataType}-Attribut in \el{ItemDef} wird \enquote{string} gesetzt.
Das funktioniert für alle drei Freitextfragetypen, kurz, lang und riesig so.
Im Falle von \el{Mehrere Texte} wird wieder eine Frage pro Subfrage genutzt.
\el{Input on Demand} und \el{Browser Detect} werden nicht gemappt. Für Details siehe \cref{d:leave}.

\subsubsection{Maskenfragen}

Für den Typ \el{Datum/Zeit} wird der \el{DataType} auf \enquote{datetime} gesetzt.
Für \el{Zahleneingabe} wird der \el{DataType} auf \enquote{float} gesetzt. %TODO: Auch integer?
Für \el{Mehrfache Zahlen} wird wieder eine Frage pro Subfrage erstellt %TODO: Conditions
%TODO Gleichung
Es gibt mehrere Typen, bei denen es feste Antwortmöglichkeiten gibt und daher eine CodeList implizit aus dem Typ erstellt wird:
\el{Ja/Nein}, \el{Geschlecht}.
\el{Ranking}, \el{Textanzeige}, \el{Dateiupload} und \el{Sprachumschaltung} werden nicht gemappt. Für weitere Details siehe \cref{d:leave}.

\subsection{Antwortmöglichkeiten}


Grundsätzlich wird jedes Mal, wenn es eine vordefinierte Liste an Antwortmöglichkeiten gibt, eine CodeList genutzt, um diese Liste in ODM darzustellen.
Für die Fragen, wo man mit 1 bis 5 oder 1 bis 10 antworten kann, wird eine simple Liste genutzt, für alle weiteren Fragen eine komplexe Liste.
Das liegt unter anderem daran, dass LimeSurvey fast alle Antworten mit einem Buchstaben darstellt und die tatsächlichen Antworten aus mindestens einem Wort bestehen.
So werden komplexere Umwandlungen vermieden und die existierende Struktur wird übernommen.
Für selbstdefinierte Antwortmöglichkeiten ist ohnehin eine komplexe Liste notwendig, da der Ersteller der Umfrage beliebige Kombinationen für Code und Antwort definieren kann.

\subsection{Antworten}

Als \el{StudyOID} und \el{MetaDataVersionOID} der \el{ClinicalData} werden die entsprechenden OIDs genutzt.
Jede \el{row} aus dem LSR Dokument wird auf ein \el{SubjectData} Element abgebildet.
Als \el{SubjectKey} wird die \el{id} genutzt.
Für \el{StudyEventOID} und \el{FormOID} werden die bereits erstellten Werte eingetragen.
Als \el{ItemGroupOID} wird die \el{gid} gesetzt.
Als \el{ItemOID} des \el{ItemData} Elements wird ein Teil des Elementnamens genutzt, nämlich \enquote{\{qid\}\{ext\}}, in \el{Value} wird der Text des Elements eingetragen.
Da die OIDs der Fragen vorher bereits so gewählt wurden, dass sie mit dieser Stuktur übereinstimmen, haben wir bereits funktionierende Referenzen, ohne weitere Umwandlungen vornehmen zu müssen.

\subsection{Themes und Frageattribute}

% - Werden nicht übernommen
% 	- ODM dient zum Austausch der Fragen/Antworten, nicht die Art und Weise, wie sie dargestellt werden

Die Themes werden nicht in ODM übernommen. Weitere Informationen gibt es in \cref{d:themes}.
Auch von den Frageattributen werden fast keine übernommen, da die meisten der visuellen Darstellung dienen.

\section{Implementierung}

\subsection{Java}

- Bietet sehr mächtige Werkzeuge zur Bearbeitung von XML
	- Kann z.B. mit mehreren Attributen in einem Element umgehen
	- Unterstützt XSD-1.1
- Wird beim IMI bereits viel genutzt

\subsection{Programmaufbau}

Das Programm trägt den Namen \enquote{lsa2odm} und besteht aus drei Paketen, \jv{app}, \jv{parser} und \jv{writer}, wobei \jv{parser} in zwei weitere Pakete aufgeteilt ist, \jv{lss} und \jv{lsr}.
in \jv{app} befindet sich die Klasse \jv{App}, welche die \jv{main}-Methode enthält.

\subsection{Eingabe}

- Archiv
	- muss entpackt werden

\subsection{Properties}

\subsection{XSD-Validierung}

- Nutze Xerces zusammen mit der erstellten XSD um eine Eingabedatei zu prüfen
- Prüfung ist nicht bindend
	- Auch invalide Datei wird weiter verarbeitet
	- Grund: Starke Versionsabhängigkeit
		- Invalide lss-Datei kann eventuell trotzdem erfolgreich umgewandelt werden
	- Zur Information für Anwender: Potentiell problematisch/inkompatibel mit Konverter

\subsection{Parsing der LimeSurvey Struktur}

Zuerst wird eine Instanz der Klasse \jv{LssParser} mit der entsprechenden LSS-Datei erstellt.
Die Klasse \jv{Survey} dient zum speichern aller gesammelten Informationen, alle für die ODM-Datei benötigten Daten werden hier abgelegt, das Objekt wird später weitergegeben.

Zunächst werden die drei in \cref{a:survey_meta} angesrochenen Elemente mit Metadaten der Studie in die \jv{survey} übernommen.
Dann werden die Fragegruppen übernommen, hierbei werden alle für das Mapping relevante Informationen gespeichert.

\subsubsection{Parsing der Fragen}
\label{im:q}

Als nächstes werden die Fragen in \jv{survey} übernommen. Dabei werden diese bereits gemäß des Mappings umgewandelt.
Das wird gemacht, um die Gesamtstruktur so früh wie möglich zu simplifizieren und nicht für jede Frage eine gesonderte Klasse erstellen zu müssen.
Da sich viele Fragen im Aufbau stark ähneln, ist dies ein simpler und schneller Weg, das Ziel zu erreichen.
Am Ende dieser Verarbeitung soll es noch vier Fragetypen geben:

\begin{enumerate}
\item[T] Eine Frage, auf die mit einem Freitext geantwortet werden kann
\item[N] Bei dieser Frage muss mit einer Zahl geantwortet werden
\item[A] Bei dieser Frage muss aus einer vordifinierten Liste an Antwortmöglichkeiten gewählt werden
\item[D] Diese Frage hat ein Datum und eine Uhrzeit als Antwort
\end{enumerate}

Zuerst wird eine Liste aller \el{row} Elemente des Frage-Elements erstellt, durch welche im Anschluss iteriert wird.
Die Klasse \jv{Question} soll alle Informationen über eine Frage speichern, entsprechend wird diese genutzt, um die Informationen jeder Reihe zu speichern.
Eine Liste der Daten ist in %TODO Bild des Konstruktors
zu sehen.
Nicht in jedem Fall wird diese Frage auch zur Umfrage hinzugefügt, wenn es sich zum Beispiel um eine Matrix-Frage handelt, wird diese Instanz nur zum Erstellen neuer Fragen genutzt.
Dann werden potentiell existierende Bedingungen hinzugefügt, dieser Vorgang wird in \cref{im:cond} beschrieben.

Anschließend gibt es ein \jv{switch}-Statement, welches einen passenden Weg zum Parsen der Frage abhängig vom Typ ausführt.

Für Textfragen wird hier nur der Typ geändert.
Bei Datum/Zeit-Fragen wird die \el{qid} zu einer Liste hinzugefügt, welche später in \cref{im:ans} gebraucht wird.
Eine numerische Frage braucht keine weitere Bearbeitung.


Dabei wird die Frage-ID wie folgt aufgebaut: \enquote{\{Parent\_QID\} + \{Title(y-Axis)\}\_\{Title(x-Axis)\}}.

\subsubsection{Parsing der Anzeige-Bedingungen}
\label{im:cond}

Da die Bedingungen innerhalb des LSS-Formates ohnehin als Elemente gespeichert werden und nicht als ExpressionScript, ergibt es mehr Sinn, diese nicht wieder in ExpressionScript umzuwandeln, sondern direkt in die Syntax des IMI.
Die in LimeSurvey mit ExpressionScript formulierten Bedingungen geben an, wann eine Frage angezeigt werden soll.
Die in ODM definierten Bedingungen müssen zu \enquote{True} evaluieren, wenn eine Frage nicht angezeigt werden soll.
Der fertige Ausruck muss am Ende also negiert werden.
Dann werden alle Bedingungen rausgesucht, welche zur \el{qid} gehören.
Diese sollen nun durch ein logisches \enquote{Und} verknüpft werden.

Die Frage aus \el{cfieldname} wird mittels des regulären Ausdrucks \enquote{\textasciicircum\textbackslash\textbackslash d+X(\textbackslash\textbackslash d+)X(.+?)\$} so verarbeitet, dass wir die darin enthaltene \el{gid} und \el{qid} der Frage enthalten.
Mit diesen, der Dummy-ID für das \jv{StudyEvent} und der Umfragen-ID wird dann ein Pfad gemäß der IMI-Syntax erstellt.

Handelt es sich nicht um einen Regulären Ausdruck, der als Operator genutzt wird, werden folgende drei Teile in dieser Reihenfolge aneinander gehangen: \el{\{PATH\} \{OPERATOR\} \{VALUE\}}.
Wobei das Element \el{method} den Operator enthält und \el{value} den Wert. \jv{PATH} ist der vorher erstellte Pfad.

Handelt es sich um einen regulären Ausdruck, wird das führende Leerzeichen entfernt und die Bedingung in folgender Form aufgeschrieben: \el{MATCH(\{REGEX\}, \{PATH\})}.

Soll eine Antwort leer bleiben, wird \enquote{NULL} als Wert verwendet.
Bei beidem handelt es sich nicht um einen Teil der IMI-Syntax, weiteres dazu in \cref{d:imi}.

Abschließend wird der Bedingung eine OID gegeben, in der Form \el{\{qid\}\{ex\}}, wobei \el{ex} in der Properties-Datei festgelegt werden kann.
Diese wird auch in der Frage eingetragen, damit man später eine Referenz auf die Bedingung hat.

\subsection{Parsing der LimeSurvey Antworten}
\label{im:ans}

Die Klasse \jv{LsrParser}, zusammen mit den Klassen \jv{Response} und \jv{Answer} wurde erstellt, um die Antworten zu verarbeiten.
Zuerst wird in \jv{createDocument} ein neuer SAXReader erstellt, welcher die LSR-Datei in eine Instanz der Klasse Document einliest.
Selbige wird dann in \jv{parseAnswers} weiterverwendet.

Alle für das Parsing relevanten Felder stehen in \el{document/responses/rows}. Dort gibt es eine Reihe pro Beantwortung des Fragebogens.
Die Klasse \jv{Response} dient zum Speichern einer Reihe, daher werden Instanzen erstellt, um alle Informationen der LSR-Datei zu übertragen.
Als nächstes wird über alle Kind-Elemente der Reihe iteriert und es wird nach Antworten gesucht.
Diese sind an der Struktur des Element-Namens zu erkennen, sie besitzen fast den gleichen Aufbau wie der Inhalt des Elements \el{cfieldname} aus \cref{im:cond}, allerdings gibt es hier zusätzlich noch einen führenden Unterstrich.
Wir nutzen also den regulären Ausdruck \enquote{\textasciicircum\textunderscore\textbackslash\textbackslash d+X(\textbackslash\textbackslash d+)X(.+?)\$}, um pasende Elemente zu finden und mittels der Capture Groups die \jv{gid} und \jv{qid} zu erhalten.

Dann wird geprüft, ob die Antwort leer ist, in dem Fall wird sie ignoriert.
Ist sie nicht leer, wird geschaut, ob es sich um eine \el{Datum/Zeit} Frage handelt, dazu wird die in \cref{im:q} erstellte Liste genutzt. Dies ist notwendig, damit das Format dem Datentyp \enquote{xsd:dateTime} entspricht, welcher später gefordert wird.
Anschließend wird eine neue Instanz der Klasse \jv{Answer} erstellt, diese soll die Antwort auf eine Frage sichern.
Befüllt wird sie mit den vorher gewonnenen Informationen über die Frage.
Schließlich wird die Antwort mittels der Methode \jv{addToAnswers} zu \jv{answers} hinzugefügt.
Diese Methode sortiert die Antwort dabei passend ein, sodass am Ende alle Antworten zu Fragen aus der gleichen Fragegruppe in einer Liste sind.

Dann wird die \jv{Response} in die ensprechende Liste hinzugefügt.
Zuletzt werden die Antworten in das ODM Dokument übertragen, falls es bereits 1000 in \jv{responses} gibt und dann wird die Liste geleert.
Dadurch soll die Menge an gebrauchtem RAM verringert werden.

\subsection{Ausgabe als ODM-Datei}

Mittels der Klasse \jv{ODMWriter} soll eine neue ODM-Datei erstellt werden. Der Konstruktor nimmt dabei die beim Parsing erstellte \jv{Survey} entgegen.
Die Methode \jv{createODMFile} dient vor allem als Caller für andere Methoden, welche die eigentlichen Funktionen ausführen.

Zuerst erstellt \jv{createODMRoot} das Wurzelelement \el{ODM} mit allen benötigten Attributen.
Als nächstes wird \jv{addStudyData} aufgerufen. Hier werden die Elemente \el{Study}, sowie die globalen Variablen mittels der Dummy-Werte aus der Properties-Datei erstellt.
Weiterhin werden die Elemente \el{MetaDataVersion},\el{Protocol}, \el{StudyEventDef} und \el{Form} erstellt.
Die \jv{meta\_data\_oid} besteht dabei aus dem Prefix in der Properties-Datei und der Studien-ID.
\el{OID} und \el{Name} des \el{StudyEvent's} stammen aus der Properties-Datei, das Element \el{Form} wird gemäß des Mappings befüllt.

Nun werden die Fragegruppen mittels \jv{addQuestionGroups} hinzugefügt. Wie in \cref{m:qg} beschrieben wird aus jeder \jv{QuestionGroup} eine \el{ItemGroupDef}.
Im Formular wird die entsprechende Referenz auf die Fragegruppe eingefügt.
Gibt es eine Beschreibung, wird sie in eine Beschreibung in der \el{ItemGroupDef} eingefügt.
Die Fragen brauchen später Referenzen in den Fragegruppen, daher werden Referenzen auf alle Fragegruppen gespeichert, sodass man später einfach Elemente hinzufügen kann.

Danach werden alle Fragen eingefügt.
%TODO

% Dieses Kapitel sollte die Ergebnisse beinhalten, die mit den Methoden aus \autoref{ch:methodik} erstellt wurden.

% \begin{table}[h]
% \caption{Beispieltabelle}
% \begin{center}
% 	\begin{tabular}{|c||c|c|}
% 		\hline
% 		Spalte1 & Spalte2 & Spalte3 \\
% 		\hline\hline
% 		   1    &    2    &    3    \\
% 		\hline
% 	\end{tabular}
% \end{center}
% \label{tbl:table}
% \end{table}
